---
description: 匹配规则
tabTrigger:  std-reg 50 rule
scope:       source.js
---
/**
 * 字面量字符和元字符
 * 字面量字符:(literal characters)
      大部分字符在正则表达式中,就是字面的含义,比如/a/匹配a,/b/匹配b.
      如果在正则表达式之中,某个字符只表示它字面的含义,那么它们就叫做“字面量字符”.
 * 元字符:(metacharacters) 除了字面量字符以外,还有一部分字符有特殊含义,不代表字面的意思.
 * 原字符主要有以下几个.
      1 点字符（.), 2 位置字符(^$) 3 选择符（|）
      4 其他的元字符还包括\、\*、+、?、()、[]、{}等
 */
// 下面代码中正则表达式的dog,就是字面量字符,所以/dog/匹配old dog,因为它就表示d, o, g三个字母连在一起.
/dog/.test('old dog') // true
// (1)点字符(.)
// 点字符(.)匹配除回车(\r), 换行(\n) , 行分隔符(\u2028)和段分隔符(\u2029)以外的所有字符.
// 注意,对于码点大于0xFFFF字符,点字符不能正确匹配,会认为这是两个字符.
// 下面代码中,c.t匹配c和t之间包含任意一个字符的情况,
// 只要这三个字符在同一行,比如cat, c2t, c-t等等,但是不匹配coot.
/c.t/
// (2)位置字符
// 位置字符用来提示字符所处的位置,主要有两个字符.
//     ^ 表示字符串的开始位置
//     $ 表示字符串的结束位置
// test必须出现在开始位置
/^test/.test('test123') // true
// test必须出现在结束位置
/test$/.test('new test') // true
// 从开始位置到结束位置只有test
/^test$/.test('test') // true
/^test$/.test('test test') // false
// (3)选择符(|)
// 竖线符号(|)在正则表达式中表示“或关系”(OR),即cat|dog表示匹配cat或dog.
/11|22/.test('911') // true
// 多个选择符可以联合使用.
// 匹配fred, barney, betty之中的一个
/fred|barney|betty/
// 选择符会包括它前后的多个字符,比如/ab|cd/指的是匹配ab或者cd,而不是指匹配b或者c.
// 如果想修改这个行为,可以使用圆括号.
下面代码指的是,a和b之间有一个空格或者一个制表符.
/a( |\t)b/.test('a\tb') // true
// 其他的元字符还包括\, \*, +, ?, (), [], {}等,将在下文解释.
/**
 * 转义符
 * 正则表达式中那些有特殊含义的元字符,如果要匹配它们本身,就需要在它们前面要加上反斜杠.
 * 比如要匹配+,就要写成\+.
 */
// 下面代码中,第一个正则表达式之所以不匹配,因为加号是元字符,不代表自身.第二个正则表达式使用反斜杠对加号转义,就能匹配成功.
/1+1/.test('1+1') // false
/1\+1/.test('1+1') // true
// 正则表达式中,需要反斜杠转义的,一共有12个字符: ^, ., [, $, (, ), |, *, +, ?, {, \
// 需要特别注意的是,如果使用RegExp方法生成正则对象,转义需要使用两个斜杠,因为字符串内部会先转义一次.
// 下面代码中,RegExp作为构造函数,参数是一个字符串.
// 但是,在字符串内部,反斜杠也是转义字符,
// 所以它会先被反斜杠转义一次,然后再被正则表达式转义一次,
// 因此需要两个反斜杠转义.
(new RegExp('1\+1')).test('1+1') // false
(new RegExp('1\\+1')).test('1+1') // true
/**
 * 特殊字符
 * 正则表达式对一些不能打印的特殊字符,提供了表达方法.
      \cX 表示Ctrl-[X],其中的X是A-Z之中任一个英文字母,用来匹配控制字符.
      [\b] 匹配退格键(U+0008),不要与\b混淆.
      \n 匹配换行键.
      \r 匹配回车键.
      \t 匹配制表符 tab(U+0009).
      \v 匹配垂直制表符(U+000B).
      \f 匹配换页符(U+000C).
      \0 匹配null字符(U+0000).
      \xhh 匹配一个以两位十六进制数(\x00-\xFF)表示的字符.
      \uhhhh 匹配一个以四位十六进制数(\u0000-\uFFFF)表示的 Unicode 字符.
 */
/**
 * 字符类
 * 字符类(class)表示有一系列字符可供选择,只要匹配其中一个就可以了.
      所有可供选择的字符都放在方括号内,比如[xyz] 表示x, y, z之中任选一个匹配.
 */
// 下面代码中,字符串hello world不包含a, b, c这三个字母中的任一个,所以返回false;
// 字符串apple包含字母a,所以返回true.
/[abc]/.test('hello world') // false
/[abc]/.test('apple') // true
// 有两个字符在字符类中有特殊含义.
// (1)脱字符(^)
// 如果方括号内的第一个字符是[^],则表示除了字符类之中的字符,其他字符都可以匹配.
// 比如,[^xyz]表示除了x, y, z之外都可以匹配.
// 下面代码中,字符串hello world不包含字母a, b, c中的任一个,所以返回true;
// 字符串bbcd包含a, b, c以外的字母 d ,所以返回 true.
// 字符串bbc不包含a, b, c以外的字母,所以返回false.
/[^abc]/.test('hello world') // true
/[^abc]/.test('bbcd') // true
/[^abc]/.test('bbc') // false
// 如果方括号内没有其他字符,即只有[^],就表示匹配一切字符,其中包括换行符.
// 相比之下,点号作为元字符(.)是不包括换行符的.
var s = 'Please yes\nmake my day!';
s.match(/yes.*day/) // null
s.match(/yes[^]*day/) // [ 'yes\nmake my day']
下面代码中,字符串s含有一个换行符,点号不包括换行符,所以第一个正则表达式匹配失败;第二个正则表达式[^]包含一切字符,所以匹配成功.
    注意,脱字符只有在字符类的第一个位置才有特殊含义,否则就是字面含义.
/**
 * (2)连字符(-)
 * 某些情况下,对于连续序列的字符,连字符(-)用来提供简写形式,表示字符的连续范围.
      比如,[abc]可以写成[a-c],[0123456789]可以写成[0-9],同理[A-Z]表示26个大写字母.
 * 以下都是合法的字符类简写形式.
      [0-9.,]
      [0-9a-fA-F]
      [a-zA-Z0-9-]
      [1-31] 不代表1到31,只代表1到3.
 */
// 下面代码中,当连字号(dash)不出现在方括号之中,就不具备简写的作用,
// 只代表字面的含义,所以不匹配字符b.只有当连字号用在方括号之中,才表示连续的字符序列.
/a-z/.test('b') // false
/[a-z]/.test('b') // true
// 连字符还可以用来指定 Unicode 字符的范围.
// 下面代码中,\u0128-\uFFFF表示匹配码点在0128到FFFF之间的所有字符.
var str = "\u0130\u0131\u0132";
/[\u0128-\uFFFF]/.test(str) // true
// 另外,不要过分使用连字符,设定一个很大的范围,否则很可能选中意料之外的字符.
// 最典型的例子就是[A-z],表面上它是选中从大写的A到小写的z之间52个字母,
// 但是由于在 ASCII 编码之中,大写字母与小写字母之间还有其他字符,结果就会出现意料之外的结果.
// 下面代码中,由于反斜杠('\')的ASCII码在大写字母与小写字母之间,结果会被选中.
/[A-z]/.test('\\') // true
/**
 * 预定义模式
 * 预定义模式指的是某些常见模式的简写方式.
      \d 匹配0-9之间的任一数字,相当于[0-9].
      \D 匹配所有0-9以外的字符,相当于[^0-9].
      \w 匹配任意的字母, 数字和下划线,相当于[A-Za-z0-9_].
      \W 除所有字母, 数字和下划线以外的字符,相当于[^A-Za-z0-9_].
      \s 匹配空格(包括换行符, 制表符, 空格符等),相等于[ \t\r\n\v\f].
      \S 匹配非空格的字符,相当于[^ \t\r\n\v\f].
      \b 匹配词的边界.
      \B 匹配非词边界,即在词的内部.
 */
// 下面代码中,\s表示空格,所以匹配结果会包括空格.
// \b表示词的边界,所以world的词首必须独立(词尾是否独立未指定),才会匹配.
// 同理,\B表示非词的边界,只有world的词首不独立,才会匹配.
// \s 的例子
/\s\w*/.exec('hello world') // [" world"]
// \b 的例子
/\bworld/.test('hello world') // true
/\bworld/.test('hello-world') // true
/\bworld/.test('helloworld') // false
// \B 的例子
/\Bworld/.test('hello-world') // false
/\Bworld/.test('helloworld') // true
// 通常,正则表达式遇到换行符(\n)就会停止匹配.
// 下面代码中,字符串html包含一个换行符,结果点字符(.)不匹配换行符,导致匹配结果可能不符合原意.这时使用\s字符类,就能包括换行符.
var html = "<b>Hello</b>\n<i>world!</i>";
/.*/.exec(html)[0]
// "<b>Hello</b>"
// 下面代码中,[\S\s]指代一切字符.
var html = "<b>Hello</b>\n<i>world!</i>";
/[\S\s]*/.exec(html)[0]
// "<b>Hello</b>\n<i>world!</i>"
/**
 * 重复类
 * 模式的精确匹配次数,使用大括号({})表示.
 * {n}表示恰好重复n次,{n,}表示至少重复n次,{n,m}表示重复不少于n次,不多于m次.
 */
/lo{2}k/.test('look') // true
/lo{2,5}k/.test('looook') // true
/**
 * 量词符
 * 量词符用来设定某个模式出现的次数.
      ? 问号表示某个模式出现0次或1次,等同于{0, 1}.
      * 星号表示某个模式出现0次或多次,等同于{0,}.
      + 加号表示某个模式出现1次或多次,等同于{1,}.
 */
// t 出现0次或1次
/t?est/.test('test') // true
/t?est/.test('est') // true
// t 出现1次或多次
/t+est/.test('test') // true
/t+est/.test('ttest') // true
// t 出现0次或多次
/t*est/.test('tttest') // true
/t*est/.test('est') // true
/**
 * 贪婪模式
 * 上一小节的三个量词符,默认情况下都是最大可能匹配,即匹配直到下一个字符不满足匹配规则为止.这被称为贪婪模式.
 */
// 下面代码中,模式是/a+/,表示匹配1个a或多个a,那么到底会匹配几个a呢？因为默认是贪婪模式,
// 会一直匹配到字符a不出现为止,所以匹配结果是3个a.
var s = 'aaa';
s.match(/a+/) // ["aaa"]
// 如果想将贪婪模式改为非贪婪模式,可以在量词符后面加一个问号.
// 下面代码中,模式结尾添加了一个问号/a+?/,这时就改为非贪婪模式,一旦条件满足,就不再往下匹配.
var s = 'aaa';
s.match(/a+?/) // ["a"]
// 除了非贪婪模式的加号,还有非贪婪模式的星号(*)和非贪婪模式的问号(?).
'abb'.match(/ab*b/) // ["abb"] // 0次或多次 默认贪婪多次
'abb'.match(/ab*?b/) // ["ab"] // 非贪婪,匹配 0 次
'abb'.match(/ab?b/) // ["abb"] // 0次或1次, 默认 1 次
'abb'.match(/ab??b/) // ["ab"] // 非贪婪,匹配 0 次
/**
 * 修饰符
 * 修饰符(modifier)表示模式的附加规则,放在正则模式的最尾部.
 * 修饰符可以单个使用,也可以多个一起使用.
 */
// 单个修饰符
var regex = /test/i;
// 多个修饰符
var regex = /test/ig;
// (1)g 修饰符
// 默认情况下,第一次匹配成功后,正则对象就停止向下匹配了.g修饰符表示全局匹配(global),
// 加上它以后,正则对象将匹配全部符合条件的结果,主要用于搜索和替换.
// 下面代码中,正则模式不含g修饰符,每次都是从字符串头部开始匹配.所以,连续做了三次匹配,都返回true.
var regex = /b/;
var str = 'abba';
regex.test(str); // true
regex.test(str); // true
regex.test(str); // true
// 下面代码中,正则模式含有g修饰符,每次都是从上一次匹配成功处,开始向后匹配.
// 因为字符串abba只有两个b,所以前两次匹配结果为true,第三次匹配结果为false.
var regex = /b/g;
var str = 'abba';
regex.test(str); // true
regex.test(str); // true
regex.test(str); // false
// (2)i 修饰符
// 默认情况下,正则对象区分字母的大小写,加上i修饰符以后表示忽略大小写(ignorecase).
/abc/.test('ABC') // false
/abc/i.test('ABC') // true
// (3)m 修饰符
// m修饰符表示多行模式(multiline),会修改^和$的行为.默认情况下(即不加m修饰符时),
// ^和$匹配字符串的开始处和结尾处,加上m修饰符以后,^和$还会匹配行首和行尾,即^和$会识别换行符(\n).
// 下面的代码中,字符串结尾处有一个换行符.如果不加m修饰符,匹配不成功,因为字符串的结尾不是world;加上以后,$可以匹配行尾.
/world$/.test('hello world\n') // false
/world$/m.test('hello world\n') // true
// 下面代码要求匹配行首的b,如果不加m修饰符,就相当于b只能处在字符串的开始处.加上b修饰符以后,换行符\n也会被认为是一行的开始.
/^b/m.test('a\nb') // true
/**
 * 组匹配
 * 正则表达式的括号表示分组匹配,括号中的模式可以用来匹配分组的内容.
 */
// (1)概述
// 下面代码中,第一个模式没有括号,结果+只表示重复字母d,第二个模式有括号,结果+就表示匹配fred这个词.
/fred+/.test('fredd') // true
/(fred)+/.test('fredfred') // true
// 下面是另外一个分组捕获的例子.
// 下面代码中,正则表达式/(.)b(.)/一共使用两个括号,第一个括号捕获a,第二个括号捕获c.
var m = 'abcabc'.match(/(.)b(.)/);
m // ['abc', 'a', 'c']
// 注意,使用组匹配时,不宜同时使用g修饰符,否则match方法不会捕获分组的内容.
// 下面代码使用带g修饰符的正则表达式,结果match方法只捕获了匹配整个表达式的部分.
// 这时必须使用正则表达式的exec方法,配合循环,才能读到每一轮匹配的组捕获.
var m = 'abcabc'.match(/(.)b(.)/g);
m // ['abc', 'abc']
var str = 'abcabc';
var reg = /(.)b(.)/g;
while (true) {
  var result = reg.exec(str);
  if (!result) break;
  console.log(result);
}
// ["abc", "a", "c"]
// ["abc", "a", "c"]
// 正则表达式内部,还可以用\n引用括号匹配的内容,n是从1开始的自然数,表示对应顺序的括号.
// 下面的代码中,\1表示第一个括号匹配的内容(即a),\2表示第二个括号匹配的内容(即c).
/(.)b(.)\1b\2/.test("abcabc")
// true
// 下面是另外一个例子.
/y(..)(.)\2\1/.test('yabccab') // true
// 括号还可以嵌套.
// 下面代码中,\1指向外层括号(匹配abab),\2指向内层括号.(匹配ab)
/y((..)\2)\1/.test('yabababab') // true
// 组匹配非常有用,下面是一个匹配网页标签的例子, 数组第二个元素 b 就是标签名
// 下面代码中,圆括号匹配尖括号之中的标签,而\1就表示对应的闭合标签.
var tagName = /<([^>]+)>[^<]*<\/\1>/;
tagName.exec("<b>bold</b>") // Array [ "<b>bold</b>", "b" ]
// 下面代码略加修改,就能捕获带有属性的标签.
var html = '<b class="hello">Hello</b><i>world</i>';
var tag = /<(\w+)([^>]*)>(.*?)<\/\1>/g;
var match = tag.exec(html);
match[1] // "b"
match[2] // " class="hello""
match[3] // "Hello"
match = tag.exec(html);
match[1] // "i"
match[2] // ""
match[3] // "world"
(2)非捕获组
(?:x)称为非捕获组(Non-capturing group),表示不返回该组匹配的内容,即匹配的结果中不计入这个括号.
非捕获组的作用请考虑这样一个场景,假定需要匹配foo或者foofoo,正则表达式就应该写成/(foo){1, 2}/,但是这样会占用一个组匹配.这时,就可以使用非捕获组,将正则表达式改为/(?:foo){1, 2}/,它的作用与前一个正则是一样的,但是不会单独输出括号内部的内容.
请看下面的例子.
var m = 'abc'.match(/(?:.)b(.)/);
m // ["abc", "c"]
下面代码中的模式,一共使用了两个括号.其中第一个括号是非捕获组,所以最后返回的结果中没有第一个括号,只有第二个括号匹配的内容.
下面是用来分解网址的正则表达式.
// 正常匹配
var url = /(http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;
url.exec('http://google.com/');
// ["http://google.com/", "http", "google.com", "/"]
// 非捕获组匹配
var url = /(?:http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;
url.exec('http://google.com/');
// ["http://google.com/", "google.com", "/"]
下面的代码中,前一个正则表达式是正常匹配,第一个括号返回网络协议;后一个正则表达式是非捕获匹配,返回结果中不包括网络协议.
(3)先行断言
x(?=y)称为先行断言(Positive look-ahead),x只有在y前面才匹配,y不会被计入返回结果.比如,要匹配后面跟着百分号的数字,可以写成/\d+(?=%)/.
“先行断言”中,括号里的部分是不会返回的.
var m = 'abc'.match(/b(?=c)/);
m // ["b"]
下面的代码使用了先行断言,b在c前面所以被匹配,但是括号对应的c不会被返回.
(4)先行否定断言
x(?!y)称为先行否定断言(Negative look-ahead),x只有不在y前面才匹配,y不会被计入返回结果.比如,要匹配后面跟的不是百分号的数字,就要写成/\d+(?!%)/.
/\d+(?!\.)/.exec('3.14')
// ["14"]
下面代码中,正则表达式指定,只有不在小数点前面的数字才会被匹配,因此返回的结果就是14.
“先行否定断言”中,括号里的部分是不会返回的.
var m = 'abd'.match(/b(?!c)/);
m // ['b']
下面的代码使用了先行否定断言,b不在c前面所以被匹配,而且括号对应的d不会被返回.
